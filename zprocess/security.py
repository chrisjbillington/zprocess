from __future__ import print_function, unicode_literals, division
import sys
PY2 = sys.version_info[0] == 2
if PY2:
    str = unicode
import os
import ipaddress

import zmq
import zmq.auth
import zmq.auth.thread


class InsecureConnection(RuntimeError):
    """A plaintext socket attempted to send or receive on an external
    interface without allow_insecure=True"""
    pass


INSECURE_ERROR = ' '.join(
 """Plaintext socket send() or recv() on external network interface. This can
allow an attacker remote arbitrary code execution if you receive and unpickle
Python objects, and open your application to other attacks even if you do not.
Unless your network is fully trusted, use a preshared key generated by
zprocess.security.generate_shared_secret() to secure your connection. Provide
the shared secret to the parent Context() as the shared_secret keyword
argument. To bind only to the local interface for connections between
processes on this computer, have the binding socket use the endpoint string
'tcp://127.0.0.1'. To proceed insecurely at your own risk, use the keyword
argument allow_insecure=True to the SecureContext() or its socket()
method""".splitlines())


def generate_shared_secret():
    public_key, secret_key = zmq.curve_keypair()
    return public_key + secret_key


class SecureSocket(zmq.Socket):
    """A Socket with that configures as a zmq curve server upon bind() and as
    a curve client upon connect(), using the keys held by the parent
    Context(). Presently a single keypair is used by all clients and servers
    to authenticate each other and secure communication, and is stored as the
    concatenation of the two keys. If the keypair passed to the parent
    Context() was None, then plain sockets will be used, but
    InsecureConnection will be raised if send() or recv() are called when
    bound or connected to an external network interface. This can be supressed
    by passing allow_insecure=True to the Context.socket() call."""

    # zmq.Socket overrides __setattr__ and __getattr to set and get ZMQ
    # options, unless the name exists as a class variable. So we define dummy
    # class variables for any instance variables we want to have:
    insecure = None
    allow_insecure = None

    def __new__(cls, context, *args, **kwargs):
        if context.auth_setup_complete:
            # The context has finished initialising, use secure sockets for
            # any sockets requested by the user:
            return zmq.Socket.__new__(cls, context, *args, **kwargs)
        else:
            # Context still initialising. Use ordinary Sockets for the
            # authenticator itself a it sets itself up:
            return zmq.Socket.__new__(zmq.Socket, context, *args, **kwargs)
            

    def __init__(self, *args, **kwargs):
        zmq.Socket.__init__(self, *args, **kwargs)
        self.allow_insecure = kwargs.pop('allow_insecure', False)

    def _is_external(self, endpoint):
        """Return whether a bind or connect endpoint is on an external
        interface"""
        import socket
        if endpoint.startswith('inproc://'):
            return False
        if endpoint.startswith('tcp://'):
            host = ''.join(''.join(endpoint.split('//')[1:]).split(':')[0])
            if host == '*':
                return True
            address = socket.gethostbyname(host)
            if isinstance(address, bytes):
                address = address.decode()
            return not ipaddress.ip_address(address).is_loopback
        return True

        return orig_server, orig_publickey, orig_secretkey, orig_serverkey

    def _configure_curve(self, server):
        orig_server = self.curve_server
        if server:
            self.curve_publickey = self.context.publickey
            self.curve_secretkey = self.context.secretkey
            self.curve_server = True
        else:
            self.curve_server = False
            self.curve_publickey = self.context.publickey
            self.curve_secretkey = self.context.secretkey
            self.curve_serverkey = self.context.publickey

    def bind(self, addr):
        if self.context.auth is not None:
            prev_setting = self._configure_curve(server=True)
        try:
            result = zmq.Socket.bind(self, addr)
        except:
            if self.context.auth is not None:
                # Roll back configuration:
                self._configure_curve(server=prev_setting)
            raise
        self.insecure = self.context.auth is None and self._is_external(addr)
        return result

    def connect(self, addr):
        if self.context.auth is not None:
            prev_setting = self._configure_curve(server=False)
        try:
            result = zmq.Socket.connect(self, addr)
        except:
            if self.context.auth is not None:
                # Roll back configuration.
                self._configure_curve(server=prev_setting)
            raise
        self.insecure = self.context.auth is None and self._is_external(addr)
        return result

    def send(self, *args, **kwargs):
        if self.insecure and not self.allow_insecure:
            raise InsecureConnection(INSECURE_ERROR)
        return zmq.Socket.send(self, *args, **kwargs)

    def recv(self, *args, **kwargs):
        if self.insecure and not self.allow_insecure:
            raise InsecureConnection(INSECURE_ERROR)
        return zmq.Socket.recv(self, *args, **kwargs)


class SecureContext(zmq.Context):
    _socket_class = SecureSocket
    # zmq.Context overrides __setattr__ and __getattr to set and get ZMQ
    # options, unless the name exists as a class variable. So we define dummy
    # class variables for any instance variables we want to have:
    auth = None
    publickey = None
    secretkey = None
    auth_setup_complete = False

    def __init__(self, *args, **kwargs):
        shared_secret = kwargs.pop('shared_secret', None)
        zmq.Context.__init__(self, *args, **kwargs)
        if shared_secret is not None:
            self.publickey, self.secretkey = shared_secret[:40], shared_secret[40:]
            # Start an authenticator for this context.
            self.auth = zmq.auth.thread.ThreadAuthenticator(self)
            self.auth.start()
            self.auth.thread.authenticator.allow_any = False
            self.auth.thread.authenticator.certs['*'] = {self.publickey: True}
        self.auth_setup_complete = True


if __name__ == '__main__':
    shared_secret = generate_shared_secret()
    context = SecureContext(shared_secret=shared_secret)

    server = context.socket(zmq.PULL)
    port = server.bind_to_random_port('tcp://*')

    context2 = SecureContext(shared_secret=shared_secret)
    client = context2.socket(zmq.PUSH)
    client.connect('tcp://localhost:%d' % port)

    plaintext = os.urandom(10*1024**2)
    import time
    for i in range(10):
        start_time = time.time()
        client.send(plaintext)
        assert server.recv() == plaintext
        print(time.time() - start_time)


